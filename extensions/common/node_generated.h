// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_NODE_WASM_COMMON_H_
#define FLATBUFFERS_GENERATED_NODE_WASM_COMMON_H_

#include "flatbuffers/flatbuffers.h"

namespace wasm {
namespace common {

struct KeyVal;

struct FlatNode;

inline const flatbuffers::TypeTable *KeyValTypeTable();

inline const flatbuffers::TypeTable *FlatNodeTypeTable();

struct KeyVal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KeyValTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const KeyVal *o) const { return *key() < *o->key(); }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) && verifier.EndTable();
  }
};

struct KeyValBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyVal::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(KeyVal::VT_VALUE, value);
  }
  explicit KeyValBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValBuilder &operator=(const KeyValBuilder &);
  flatbuffers::Offset<KeyVal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyVal>(end);
    fbb_.Required(o, KeyVal::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<KeyVal> CreateKeyVal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KeyValBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyVal> CreateKeyValDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return wasm::common::CreateKeyVal(_fbb, key__, value__);
}

struct FlatNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlatNodeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NAMESPACE_ = 6,
    VT_LABELS = 8,
    VT_PLATFORM_METADATA = 10,
    VT_OWNER = 12,
    VT_WORKLOAD_NAME = 14,
    VT_ISTIO_VERSION = 16,
    VT_MESH_ID = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *namespace_() const {
    return GetPointer<const flatbuffers::String *>(VT_NAMESPACE_);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *labels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *>(
        VT_LABELS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *platform_metadata()
      const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *>(
        VT_PLATFORM_METADATA);
  }
  const flatbuffers::String *owner() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNER);
  }
  const flatbuffers::String *workload_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WORKLOAD_NAME);
  }
  const flatbuffers::String *istio_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ISTIO_VERSION);
  }
  const flatbuffers::String *mesh_id() const {
    return GetPointer<const flatbuffers::String *>(VT_MESH_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NAMESPACE_) &&
           verifier.VerifyString(namespace_()) &&
           VerifyOffset(verifier, VT_LABELS) &&
           verifier.VerifyVector(labels()) &&
           verifier.VerifyVectorOfTables(labels()) &&
           VerifyOffset(verifier, VT_PLATFORM_METADATA) &&
           verifier.VerifyVector(platform_metadata()) &&
           verifier.VerifyVectorOfTables(platform_metadata()) &&
           VerifyOffset(verifier, VT_OWNER) && verifier.VerifyString(owner()) &&
           VerifyOffset(verifier, VT_WORKLOAD_NAME) &&
           verifier.VerifyString(workload_name()) &&
           VerifyOffset(verifier, VT_ISTIO_VERSION) &&
           verifier.VerifyString(istio_version()) &&
           VerifyOffset(verifier, VT_MESH_ID) &&
           verifier.VerifyString(mesh_id()) && verifier.EndTable();
  }
};

struct FlatNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FlatNode::VT_NAME, name);
  }
  void add_namespace_(flatbuffers::Offset<flatbuffers::String> namespace_) {
    fbb_.AddOffset(FlatNode::VT_NAMESPACE_, namespace_);
  }
  void add_labels(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyVal>>>
          labels) {
    fbb_.AddOffset(FlatNode::VT_LABELS, labels);
  }
  void add_platform_metadata(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyVal>>>
          platform_metadata) {
    fbb_.AddOffset(FlatNode::VT_PLATFORM_METADATA, platform_metadata);
  }
  void add_owner(flatbuffers::Offset<flatbuffers::String> owner) {
    fbb_.AddOffset(FlatNode::VT_OWNER, owner);
  }
  void add_workload_name(
      flatbuffers::Offset<flatbuffers::String> workload_name) {
    fbb_.AddOffset(FlatNode::VT_WORKLOAD_NAME, workload_name);
  }
  void add_istio_version(
      flatbuffers::Offset<flatbuffers::String> istio_version) {
    fbb_.AddOffset(FlatNode::VT_ISTIO_VERSION, istio_version);
  }
  void add_mesh_id(flatbuffers::Offset<flatbuffers::String> mesh_id) {
    fbb_.AddOffset(FlatNode::VT_MESH_ID, mesh_id);
  }
  explicit FlatNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlatNodeBuilder &operator=(const FlatNodeBuilder &);
  flatbuffers::Offset<FlatNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlatNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlatNode> CreateFlatNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> namespace_ = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyVal>>>
        labels = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyVal>>>
        platform_metadata = 0,
    flatbuffers::Offset<flatbuffers::String> owner = 0,
    flatbuffers::Offset<flatbuffers::String> workload_name = 0,
    flatbuffers::Offset<flatbuffers::String> istio_version = 0,
    flatbuffers::Offset<flatbuffers::String> mesh_id = 0) {
  FlatNodeBuilder builder_(_fbb);
  builder_.add_mesh_id(mesh_id);
  builder_.add_istio_version(istio_version);
  builder_.add_workload_name(workload_name);
  builder_.add_owner(owner);
  builder_.add_platform_metadata(platform_metadata);
  builder_.add_labels(labels);
  builder_.add_namespace_(namespace_);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlatNode> CreateFlatNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const char *namespace_ = nullptr,
    const std::vector<flatbuffers::Offset<KeyVal>> *labels = nullptr,
    const std::vector<flatbuffers::Offset<KeyVal>> *platform_metadata = nullptr,
    const char *owner = nullptr, const char *workload_name = nullptr,
    const char *istio_version = nullptr, const char *mesh_id = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto namespace___ = namespace_ ? _fbb.CreateString(namespace_) : 0;
  auto labels__ =
      labels ? _fbb.CreateVector<flatbuffers::Offset<KeyVal>>(*labels) : 0;
  auto platform_metadata__ =
      platform_metadata
          ? _fbb.CreateVector<flatbuffers::Offset<KeyVal>>(*platform_metadata)
          : 0;
  auto owner__ = owner ? _fbb.CreateString(owner) : 0;
  auto workload_name__ = workload_name ? _fbb.CreateString(workload_name) : 0;
  auto istio_version__ = istio_version ? _fbb.CreateString(istio_version) : 0;
  auto mesh_id__ = mesh_id ? _fbb.CreateString(mesh_id) : 0;
  return wasm::common::CreateFlatNode(
      _fbb, name__, namespace___, labels__, platform_metadata__, owner__,
      workload_name__, istio_version__, mesh_id__);
}

inline const flatbuffers::TypeTable *KeyValTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_STRING, 0, -1}};
  static const char *const names[] = {"key", "value"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable *FlatNodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_STRING, 0, -1},  {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_SEQUENCE, 1, 0}, {flatbuffers::ET_SEQUENCE, 1, 0},
      {flatbuffers::ET_STRING, 0, -1},  {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_STRING, 0, -1},  {flatbuffers::ET_STRING, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {KeyValTypeTable};
  static const char *const names[] = {
      "name",  "namespace_",    "labels",        "platform_metadata",
      "owner", "workload_name", "istio_version", "mesh_id"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names};
  return &tt;
}

}  // namespace common
}  // namespace wasm

#endif  // FLATBUFFERS_GENERATED_NODE_WASM_COMMON_H_
